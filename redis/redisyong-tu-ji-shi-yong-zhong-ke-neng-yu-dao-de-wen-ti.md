#### 缓存穿透

缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。

解决方案：接口层增加校验，id&lt;=0的直接拦截；  
    从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击

#### redis 缓存雪崩

同一个时刻大量缓存失效。

​    **解决方案**

1. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
   1. 如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。
2. 设置热点数据永远不过期。

#### redis 缓存击穿

同一个时间大量的线程发起请求，同时缓存没有存（业务会先查缓存没有的话去查库然后放在缓存里），导致所有线程直接查库，数据库压力瞬间增大，造成过大压力。

解决方法

1.查询时候使用分布式锁（互斥锁），同一时刻只允许一个线程去查库放到缓存，其他线程等待获取到锁之后再查一次缓存如果获取到就不用查库了。

2.设置热点数据永远不过期

redis 分布式锁setnx

可能出现的问题

1.释放锁之前导致服务器宕机导致死锁。

**Redis对于过期键有三种清除策略**：

* 被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key
* 主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批已过期的key
* 当前已用内存超过maxmemory限定时，触发主动清理策略

#### 数据类型和运用场景

| 类型 | 简介 | 特性 | 场景 |
| :--- | :--- | :--- | :--- |
| String\(字符串\) | 二进制安全 | 可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M | --- |
| Hash\(字典\) | 键值对集合,即编程语言中的Map类型 | 适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值\(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去\) | 存储、读取、修改用户属性 |
| List\(列表\) | 链表\(双向链表\) | 增删快,提供了操作某一段元素的API | 1、最新消息排行等功能\(比如朋友圈的时间线\) 2、消息队列 |
| Set\(集合\) | 哈希表实现,元素不重复 | 1、添加、删除、查找的复杂度都是O\(1\) 2、为集合提供了求交集、并集、差集等操作 | 1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐 |
| Sorted Set\(有序集合\) | 将Set中的元素增加一个权重参数score,元素按score有序排列 | 数据插入集合时,已经进行天然排序 | 1、排行榜 2、带权重的消息队列 |

Redis key过期的方式有三种：



惰性删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key（无法保证冷数据被及时删掉）

	定期删除：Redis会定期主动淘汰一批已过期的key（随机抽取一批key检查）

	内存淘汰机制：当前已用内存超过maxmemory限定时，触发主动清理策略

————————————————

版权声明：本文为CSDN博主「咬瓶盖」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。

原文链接：https://blog.csdn.net/qq\_36223142/article/details/89399949

