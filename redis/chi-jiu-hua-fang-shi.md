## redis持久化方式

\[TOC\]

#### 一、RDB\(Redis DataBase\)快照

* RDB将数据写入一个临时文件，写入完成后用这个临时文件替换上次持久化的文件。
* 优点：**使用子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能** 
* 缺点：**RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候**

这里说的这个执行数据写入到临时文件的时间点是可以通过配置来自己确定的，通过配置**redis在n秒内如果超过m个key被修改**这执行一次RDB操作。这个操作就类似于在这个时间点来保存一次Redis的所有数据，一次快照数据。所有这个持久化方法也通常叫做snapshots。

RDB默认开启，redis.conf中的具体配置参数如下；

```
#dbfilename：持久化数据存储在本地的文件
dbfilename dump.rdb
#dir：持久化数据存储在本地的路径，如果是在/redis/redis-3.0.6/src下启动的redis-cli，则数据会存储在当前src目录下
dir ./
##snapshot触发的时机，save <seconds> <changes>  
##如下为900秒后，至少有一个变更操作，才会snapshot  
##对于此值的设置，需要谨慎，评估系统的变更操作密集程度  
##可以通过“save “””来关闭snapshot功能  
#save时间，以下分别表示更改了1个key时间隔900s进行持久化存储；更改了10个key300s进行存储；更改10000个key60s进行存储。
save 900 1
save 300 10
save 60 10000
##当snapshot时出现错误无法继续时，是否阻塞客户端“变更操作”，“错误”可能因为磁盘已满/磁盘故障/OS级别异常等  
stop-writes-on-bgsave-error yes  
##是否启用rdb文件压缩，默认为“yes”，压缩往往意味着“额外的cpu消耗”，同时也意味这较小的文件尺寸以及较短的网络传输时间  
rdbcompression yes
```

#### 二、Append-only file \(简称AOF\)

Append-only file，将“操作 + 数据”以格式化指令的方式追加到操作日志文件的尾部，在append操作返回后\(已经写入到文件或者即将写入\)，才进行实际的数据变更，“日志文件”保存了历史所有的操作过程；当server需要数据恢复时，可以直接replay此日志文件，即可还原所有的操作过程。AOF相对可靠，它和mysql中bin.log、apache.log、zookeeper中txn-log简直异曲同工。AOF文件内容是字符串，非常容易阅读和解析。

优点：**可以保持更高的数据完整性，如果设置追加file的时间是1s，如果redis发生故障，最多会丢失1s的数据；且如果日志写入不完整支持redis-check-aof来进行日志修复；AOF文件没被rewrite之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的flushall）。**  
缺点：**AOF文件比RDB文件大，且恢复需要重新执行保存的命令速度慢。**

我们可以简单的认为AOF就是日志文件，此文件只会记录“变更操作”\(例如：set/del等\)，如果server中持续的大量变更操作，将会导致AOF文件非常的庞大，意味着server失效后，数据恢复的过程将会很长；事实上，一条数据经过多次变更，将会产生多条AOF记录，其实只要保存当前的状态，历史的操作记录是可以抛弃的；因为AOF持久化模式还伴生了“AOF rewrite”。  
AOF的特性决定了它相对比较安全，如果你期望数据更少的丢失，那么可以采用AOF模式。如果AOF文件正在被写入时突然server失效，有可能导致文件的最后一次记录是不完整，你可以通过手工或者程序的方式去检测并修正不完整的记录，以便通过aof文件恢复能够正常；同时需要提醒，如果你的redis持久化手段中有aof，那么在server故障失效后再次启动前，需要检测aof文件的完整性。

AOF默认关闭，开启方法，修改配置文件reds.conf：appendonly yes

```
##此选项为aof功能的开关，默认为“no”，可以通过“yes”来开启aof功能  
##只有在“yes”下，aof重写/文件同步等特性才会生效  
appendonly yes  

##指定aof文件名称  
appendfilename appendonly.aof  

##指定aof操作中文件同步策略，有三个合法值：always everysec no,默认为everysec  
appendfsync everysec  
##在aof-rewrite期间，appendfsync是否暂缓文件同步，"no"表示“不暂缓”，“yes”表示“暂缓”，默认为“no”  
no-appendfsync-on-rewrite no  

##aof文件rewrite触发的最小文件尺寸(mb,gb),只有大于此aof文件大于此尺寸是才会触发rewrite，默认“64mb”，建议“512mb”  
auto-aof-rewrite-min-size 64mb  

##相对于“上一次”rewrite，本次rewrite触发时aof文件应该增长的百分比。  
##每一次rewrite之后，redis都会记录下此时“新aof”文件的大小(例如A)，那么当aof文件增长到A*(1 + p)之后  
##触发下一次rewrite，每一次aof记录的添加，都会检测当前aof文件的尺寸。  
auto-aof-rewrite-percentage 100
```

AOF是文件操作，对于变更操作比较密集的server，那么必将造成磁盘IO的负荷加重；此外linux对文件操作采取了“延迟写入”手段，即并非每次write操作都会触发实际磁盘操作，而是进入了buffer中，当buffer数据达到阀值时触发实际写入\(也有其他时机\)，这是linux对文件系统的优化，但是这却有可能带来隐患，如果buffer没有刷新到磁盘，此时物理机器失效\(比如断电\)，那么有可能导致最后一条或者多条aof记录的丢失。通过上述配置文件，可以得知redis提供了3中aof记录同步选项：

> * always：每一条aof记录都立即同步到文件，这是最安全的方式，也以为更多的磁盘操作和阻塞延迟，是IO开支较大。
> * everysec：每秒同步一次，性能和安全都比较中庸的方式，也是redis推荐的方式。如果遇到物理服务器故障，有可能导致最近一秒内aof记录丢失\(可能为部分丢失\)。
> * no：redis并不直接调用文件同步，而是交给操作系统来处理，操作系统可以根据buffer填充情况/通道空闲时间等择机触发同步；这是一种普通的文件操作方式。性能较好，在物理服务器故障时，数据丢失量会因OS配置有关。

其实，我们可以选择的太少，everysec是最佳的选择。如果你非常在意每个数据都极其可靠，建议你选择一款“关系性数据库”吧。  
AOF文件会不断增大，它的大小直接影响“故障恢复”的时间,而且AOF文件中历史操作是可以丢弃的。**AOF rewrite操作就是“压缩”AOF文件的过程，当然redis并没有采用“基于原aof文件”来重写的方式，而是采取了类似snapshot的方式：基于copy-on-write，全量遍历内存中数据，然后逐个序列到aof文件中。因此AOF rewrite能够正确反应当前内存数据的状态，这正是我们所需要的；\*rewrite过程中，对于新的变更操作将仍然被写入到原AOF文件中，同时这些新的变更操作也会被redis收集起来\(buffer，copy-on-write方式下，最极端的可能是所有的key都在此期间被修改，将会耗费2倍内存\)，当内存数据被全部写入到新的aof文件之后，收集的新的变更操作也将会一并追加到新的aof文件中，此后将会重命名新的aof文件为appendonly.aof,此后所有的操作都将被写入新的aof文件。**如果在rewrite过程中，出现故障，将不会影响原AOF文件的正常工作，只有当rewrite完成之后才会切换文件，因为rewrite过程是比较可靠的。\*

触发rewrite的时机可以通过配置文件来声明，同时redis中可以通过bgrewriteaof指令人工干预。

```
redis-cli -h ip -p port bgrewriteaof
```

* 1

因为rewrite操作/aof记录同步/snapshot都消耗磁盘IO，redis采取了“schedule”策略：无论是“人工干预”还是系统触发，snapshot和rewrite需要逐个被执行。

AOF rewrite过程并不阻塞客户端请求。系统会开启一个子进程来完成。

#### 三、总结

AOF和RDB各有优缺点，这是有它们各自的特点所决定：

> * 1\) AOF更加安全，可以将数据更加及时的同步到文件中，但是AOF需要较多的磁盘IO开支，AOF文件尺寸较大，文件内容恢复数度相对较慢。 
>   \*2\) snapshot，安全性较差，它是“正常时期”数据备份以及master-slave数据同步的最佳手段，文件尺寸较小，恢复数度较快。

可以通过配置文件来指定它们中的一种，或者同时使用它们\(不建议同时使用\)，或者全部禁用，在架构良好的环境中，master通常使用AOF，slave使用snapshot，主要原因是master需要首先确保数据完整性，它作为数据备份的第一选择；slave提供只读服务\(目前slave只能提供读取服务\)，它的主要目的就是快速响应客户端read请求；但是如果你的redis运行在网络稳定性差/物理环境糟糕情况下，建议你master和slave均采取AOF，这个在master和slave角色切换时，可以减少“人工数据备份”/“人工引导数据恢复”的时间成本；如果你的环境一切非常良好，且服务需要接收密集性的write操作，那么建议master采取snapshot，而slave采用AOF。

### **主从**

> 通过持久化功能，Redis保证了即使在服务器重启的情况下也不会损失（或少量损失）数据，因为持久化会把内存中数据保存到硬盘上，重启会从硬盘上加载数据。  
> 。但是由于数据是存储在一台服务器上的，如果这台服务器出现硬盘故障等问题，也会导致数据丢失。为了避免单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上，这样即使有一台服务器出现故障，其他服务器依然可以继续提供服务。为此， Redis 提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上。
>
> 在复制的概念中，数据库分为两类，一类是主数据库（master），另一类是从数据库\[1\] （slave）。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。

### 数据同步

redis 2.8版本以上使用psync命令完成同步，过程分“全量”与“部分”复制  
全量复制：一般用于初次复制场景（第一次建立SLAVE后全量）  
部分复制：网络出现问题，从节点再次连接主节点时，主节点补发缺少的数据，每次数据增量同步  
心跳：主从有长连接心跳，主节点默认每10S向从节点发ping命令，repl-ping-slave-period控制发送频率

### 主从的缺点

a\)主从复制，若主节点出现问题，则不能提供服务，需要人工修改配置将从变主  
b\)主从复制主节点的写能力单机，能力有限  
c\)单机节点的存储能力也有限

### 主从故障如何故障转移

a\)主节点\(master\)故障，从节点slave-1端执行 slaveof no one后变成新主节点；  
b\)其它的节点成为新主节点的从节点，并从新节点复制数据；  
c\)需要人工干预，无法实现高可用。

## Redis哨兵机制（Sentinel）

为什么要有哨兵机制？

​       哨兵机制的出现是为了解决主从复制的缺点的

哨兵机制\(sentinel\)的高可用

原理：当主节点出现故障时，由Redis Sentinel自动完成故障发现和转移，并通知应用方，实现高可用性。

![](/assets/rediszc1.png)

实整个过程只需要一个哨兵节点来完成，首先使用Raft算法（选举算法）实现选举机制，选出一个哨兵节点来完成转移和通知

### 哨兵的定时监控任务

任务1：每个哨兵节点每10秒会向主节点和从节点发送info命令获取最拓扑结构图，哨兵配置时只要配置对主节点的监控即可，通过向主节点发送info，获取从节点的信息，并当有新的从节点加入时可以马上感知到

![](/assets/rediszc3.png)

任务2：每个哨兵节点每隔2秒会向redis数据节点的指定频道上发送该哨兵节点对于主节点的判断以及当前哨兵节点的信息，同时每个哨兵节点也会订阅该频道，来了解其它哨兵节点的信息及对主节点的判断，其实就是通过消息publish和subscribe来完成的

![](/assets/rediszc4.png)

任务3：每隔1秒每个哨兵会向主节点、从节点及其余哨兵节点发送一次ping命令做一次心跳检测，这个也是哨兵用来判断节点是否正常的重要依据

![](/assets/rediszc6.png)

客观下线：当主观下线的节点是主节点时，此时该哨兵3节点会通过指令sentinel is-masterdown-by-addr寻求其它哨兵节点对主节点的判断，当超过quorum（选举）个数，此时哨兵节点则认为该主节点确实有问题，这样就客观下线了，大部分哨兵节点都同意下线操作，也就说是客观下线

![](/assets/rediszc7.png)

### 领导者哨兵选举流程

a\)每个在线的哨兵节点都可以成为领导者，当它确认（比如哨兵3）主节点下线时，会向其它哨兵发is-master-down-by-addr命令，征求判断并要求将自己设置为领导者，由领导者处理故障转移；  
b\)当其它哨兵收到此命令时，可以同意或者拒绝它成为领导者；  
c\)如果哨兵3发现自己在选举的票数大于等于num\(sentinels\)/2+1时，将成为领导者，如果没有超过，继续选举…………

![](/assets/rediszc8.png)

### 故障转移机制

a\)由Sentinel节点定期监控发现主节点是否出现了故障

sentinel会向master发送心跳PING来确认master是否存活，如果master在“一定时间范围”内不回应PONG 或者是回复了一个错误消息，那么这个sentinel会主观地\(单方面地\)认为这个master已经不可用了

![](/assets/rediszc12.png)

b\) 当主节点出现故障，此时3个Sentinel节点共同选举了Sentinel3节点为领导，负载处理主节点的故障转移

![](/assets/rediszc23.png)

c\) 由Sentinel3领导者节点执行故障转移，过程和主从复制一样，但是自动执行

![](/assets/rediszc22.png)

流程：

1. 将slave-1脱离原从节点，升级主节点，

​         \2. 将从节点slave-2指向新的主节点

​         \3. 通知客户端主节点已更换

​         \4. 将原主节点（oldMaster）变成从节点，指向新的主节点

d\) 故障转移后的redis sentinel的拓扑结构图

![](/assets/rediszc21.png)

### 哨兵机制－故障转移详细流程-确认主节点

a\) 过滤掉不健康的（下线或断线），没有回复过哨兵ping响应的从节点

b\) 选择salve-priority从节点优先级最高（redis.conf）的

c\) 选择复制偏移量最大，指复制最完整的从节点

### 实战：如何安装和部署哨兵

以3个Sentinel节点、2个从节点、1个主节点为例进行安装部署

![](/assets/rediszc24.png)

### **主从数据库的配置** 哨兵

从redis的conf文件加入 slaveof ip port  最新版本 replicaof ip port  
或者从redis启动时  redis-server --port 6380 --slaveof 127.0.0.1 6379  
    从数据库一般是只读，可以改为可写，但写入的数据很容易被主同步没，所以还是只读就可以。  
也可以在运行是使用slaveof ip port命令，停止原来的主，切换成刚刚设置的主  slaveof no one会把自己变成主

【坑2】slaveof 127.0.0.1\(删掉\) 10.1.0.252 16379

【坑3】 masterauth redis0326\(主节点密码\) ---- 注意, 主节点redis有密码,必须项

【坑4】bind 127.0.0.1\(删掉\) bind 10.1.0.224 \(本机IP \)

​    当从数据库启动时，会向主数据库发送sync命令，主数据库接收到sync后开始在后台报错快照rdb，在保存快照期间受到的命名缓存起来，当快照完成时，主数据库会将快照和缓存的命令一块发送给从。复制初始化结束。  
之后，主每受到1个命令就同步发送给从。  
当出现断开重连后，2.8之后的版本会将断线期间的命令传给重数据库。增量复制

主从复制是乐观复制，当客户端发送写执行给主，主执行完立即将结果返回客户端，并异步的把命令发送给从，从而不影响性能。也可以设置至少同步给多少个从主才可写。  
无硬盘复制:如果硬盘效率低将会影响复制性能，2.8之后可以设置无硬盘复制，repl-diskless-sync yes

**使用哨兵模式，自动监视Master节点，当前挂掉后，自动将Slaver节点变为Master节点**

​       a\) sentinel.conf配置文件，修改sentinel monitor host6379 127.0.0.1 6379 1，其它使用默认即可  
​           host6379 主机名称，随便起    主机IP 端口 1表示选举，某个slaver得到超过1票则成成为Master节点

​       b\) 启动sentinel： ./redis-sentinel ../sentinel.conf

主从切换过程：

（1）      slave leader升级为master  
（2）      其他slave修改为新master的slave  
（3）      客户端修改连接  
（4）      老的master如果重启成功，变为新master的slave

哨兵监控1主2从，停掉主，哨兵会选出1个从作为主，变成1主1从。然而当我把原来的主再起来，它不会作为从，只是个独立的节点。

如果在新的主刚被选出来时，我把原来的主起来，它就能成为新主的从节点。  
如果在新的主选出来过一会再起原来的主，就不能成为新主的从节点  
或者在老的主起来后，重启哨兵也能把它变成从，哨兵配置文件里有，哨兵会执行“+convert-to-slave”

**1. 前提：**先搭好一主两从redis的主从复制，和之前的主从复制搭建一样，搭建方式如下：

A）主节点6379节点（/usr/local/bin/conf/redis6379.conf）：

修改 requirepass 123456，注释掉\#bind 127.0.0.1

B\) 从节点redis.conf

修改 requirepass 123456 ,注释掉\#bind 127.0.0.1,

访问主节点的密码masterauth 123456  slaveof 192.168.152.128 6379

​    **注意\*\***：\*\*当主从起来后，主节点可读写，从节点只可读不可写

**2. redis sentinel哨兵机制核心配置**\(也是3个节点\)：

​       /usr/local/bin/conf/sentinel.conf

默认端口 26379

然后：sentinel monitor mymaster 192.168.152.128 **6379** 2  //监听主节点6379

​      sentinel auth-pass mymaster 12345678     //连接主节点时的密码

**三个配置除端口外，其它一样。**

**3. 哨兵其它的配置**：只要修改每个sentinel.conf的这段配置即可：

sentinel monitor mymaster 192.168.152.128 6379 2

//监控主节点的IP地址端口，sentinel监控的master的名字叫做mymaster，2代表，当集群中有2个sentinel认为master死了时，才能真正认为该master已经不可用了

sentinel auth-pass mymaster 12345678  //sentinel连主节点的密码

sentinel config-epoch mymaster 2  //故障转移时最多可以有2从节点同时对新主节点进行数据同步

sentinel leader-epoch mymaster 2

sentinel failover-timeout mymasterA **180000** //故障转移超时时间180s，

a,如果转移超时失败，下次转移时时间为之前的2倍；

b,从节点变主节点时，从节点执行slaveof no one命令一直失败的话，当时间超过**180S**时，则故障转移失败

c,从节点复制新主节点时间超过**180S**转移失败

sentinel down-after-milliseconds mymasterA **300000**//sentinel节点定期向主节点ping命令，当超过了**300S**时间后没有回复，可能就认定为此主节点出现故障了……

sentinel parallel-syncs mymasterA **1** //故障转移后，**1**代表每个从节点按顺序排队一个一个复制主节点数据，如果为3，指3个从节点同时并发复制主节点数据，不会影响阻塞，但存在网络和IO开销

**4. 启动redis服务和sentinel服务:**

**a\)先把之前安装的redis里面的标绿色的文件都拷贝到 usr/local/bin目录下，然后再再bin目录下新建一个conf文件夹存放配置好的redis主从配置文件和哨兵配置文件**

```
cd redis/redis5.0.4/src
./redis_sentinel ../sentinel.conf
```



