**	线程**（英语：thread）是[操作系统](https://baike.baidu.com/item/操作系统)能够进行运算[调度](https://baike.baidu.com/item/调度)的最小单位。它被包含在[进程](https://baike.baidu.com/item/进程)之中，是[进程](https://baike.baidu.com/item/进程)中的实际运作单位。一条线程指的是[进程](https://baike.baidu.com/item/进程)中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务

一个进程可以有很多线程，每条线程并行执行不同的任务。

多线程：指的是这个程序（一个进程）运行时产生了不止一个线程

* 并行与并发：

  * 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。
  * 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。

  线程的几种状态:

**1、新建状态\(New\)**：新创建了一个线程对象。

**2、就绪状态\(Runnable\)**：线程对象创建后，其他线程调用了该对象的start\(\)方法。该状态的线程位于“**可运行线程池**”中，变得可运行，只**等待获取CPU的使用权**。**即在就绪状态的进程除\*\***CPU之外，其它的运行所需资源都已全部获得。

**3、运行状态\(Running\)：**就绪状态的线程获取了CPU，执行程序代码。

**4、阻塞状态\(Blocked\)：**阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。

**其中阻塞的情况分三种：**

\(1\)、**等待阻塞**：运行的线程执行wait\(\)方法，该线程会释放占用的所有资源，JVM会把该线程放入“**等待池”**中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify\(\)或notifyAll\(\)方法才能被唤醒，

\(2\)、**同步阻塞**：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入**“锁池”**中。

\(3\)、**其他阻塞**：运行的线程执行sleep\(\)或join\(\)方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep\(\)状态超时、join\(\)等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态

**5、死亡状态\(Dead\)：**线程执行完了或者因遇到error或exception退出了run\(\)方法，该线程结束生命周期。线程调用 stop\(\)方法、destory\(\)方法或 run\(\)方法执行结束后，线程即处于死亡状态。处于死亡状态的线程不具有继续运行的能力。

可以通过getState\(\)方法来获取线程当前的状态：NEW（新创建） 、RUNNABLE（就绪状态）、BLOCKED（阻塞）、WAITING（等待）、TIMED\_WAITING（计时等待）、TERMINATED（终止）

##### ![](/assets/thread1.png)

##### 

##### Thread 方法

sleep\(long millis\)

使当前线程进入休眠阶段，状态变为：TIME\_WAITING 让线程睡眠 n 毫秒不会释放锁

interrupt\(\)

中断当前线程的执行，允许当前线程对自身进行中断，否则将会校验调用方线程是否有对该线程的权限。

interrupted\(\)，返回true或者false：

查看当前线程是否处于中断状态，这个方法比较特殊之处在于，如果调用成功，会将当前线程的interrupt status清除。所以如果连续2次调用该方法，第二次将返回false。

isInterrupted\(\)，返回true或者false：

与上面方法相同的地方在于，该方法返回当前线程的中断状态。不同的地方在于，它不会清除当前线程的interrupt status状态。

wait\(\)

暂停当前线程，释放线程获取的锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入。

notify\(\)

唤醒当前暂停线程。

notifyAll\(\)

唤醒所有暂停的线程。

yield\(\)

执行此方法会向系统线程调度器（Schelduler）发出一个暗示，告诉其当前JAVA线程打算放弃对CPU的使用，但该暗示，有可能被调度器忽略。使用该方法，可以防止线程对CPU的过度使用，提高系统性能。

suspend()

暂停当前线程，必须其对应的resume() 被调用suspend()和resume()必须要成对出现，否则非常容易发生死锁。
因为suspend方法并不会释放锁，如果使用suspend的目标线程对一个重要的系统资源持有锁，那么没任何线程可以使用这个资源直到要suspend的目标线程被resumed，如果一个线程在resume目标线程之前尝试持有这个重要的系统资源锁再去resume目标线程，这两条线程就相互死锁了，也就冻结线程。**容易造成死锁不建议使用**。

stop()

终止当前线程，即刻停止run()方法中剩余的全部工作，包括在catch或finally语句中，并抛出ThreadDeath异常(通常情况下此异常不需要显示的捕获)，因此可能会导致一些清理性的工作的得不到完成，如文件，数据库等的关闭。会立即释放该线程所持有的所有的锁，导致数据得不到同步的处理，出现数据不一致的问题。

