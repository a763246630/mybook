# 类加载机制

### 类加载过程

类加载到使用整个过程有如下几步：

**加载 &gt;&gt; 验证 &gt;&gt; 准备 &gt;&gt; 解析 &gt;&gt; 初始化 &gt;&gt;** 使用 &gt;&gt; 卸载

#### 加载

在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用

类的main\(\)方法，new对象等等

#### 验证

校验字节码文件的正确性

#### 准备

给类的静态变量分配内存，并赋予默认值 （例如对象赋值为null，int类型为0）

#### 解析

将符号引用替换为直接引用，该阶段会把一些静态方法\(符号引用，比如

main\(\)方法\)替换为指向数据所存内存的指针或句柄等\(直接引用\)，这是所谓的**静态链**

**接**过程\(类加载期间完成\)，**动态链接**是在程序运行期间完成的将符号引用替换为直接

引用。

#### 初始化

对类的静态变量初始化为指定的值，执行静态代码块

#### **类加载器和双亲委派机制**

上面的类加载过程主要是通过类加载器来实现的，Java里有如下几种类加载器

自上而下加载类，自下而上查询类是否加载。

##### 启动类加载

负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如 rt.jar、charsets.jar等

##### 扩展类加载器

负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中

的JAR类包

##### 应用程序类加载器

负责加载ClassPath路径下的类包，主要就是加载你自己写

的那些类

##### 自定义加载器

负责加载用户自定义路径下的类包

##### 自定义一个类加载器示例

自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，一个是

loadClass\(String, boolean\)，实现了**双亲委派机制**，大体逻辑

\1. 首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，

直接返回。

\2. 如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由

父加载器加载（即调用parent.loadClass\(name, false\);）.或者是调用bootstrap类加

载器来加载。

\3. 如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器

的findClass方法来完成类加载。

![](/assets/类加载.png)

