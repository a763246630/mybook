# 类加载机制

### 类加载过程

类加载到使用整个过程有如下几步：

**加载 &gt;&gt; 验证 &gt;&gt; 准备 &gt;&gt; 解析 &gt;&gt; 初始化 &gt;&gt;** 使用 &gt;&gt; 卸载

#### 加载

在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用

类的main\(\)方法，new对象等等

#### 验证

校验字节码文件的正确性

#### 准备

给类的静态变量分配内存，并赋予默认值 （例如对象赋值为null，int类型为0）

#### 解析

将符号引用替换为直接引用，该阶段会把一些静态方法\(符号引用，比如

main\(\)方法\)替换为指向数据所存内存的指针或句柄等\(直接引用\)，这是所谓的**静态链**

**接**过程\(类加载期间完成\)，**动态链接**是在程序运行期间完成的将符号引用替换为直接

引用。

#### 初始化

对类的静态变量初始化为指定的值，执行静态代码块

#### **类加载器和双亲委派机制**

上面的类加载过程主要是通过类加载器来实现的，Java里有如下几种类加载器

自上而下加载类，自下而上查询类是否加载。

##### 启动类加载

负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如 rt.jar、charsets.jar等

##### 扩展类加载器

负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中

的JAR类包

##### 应用程序类加载器

负责加载ClassPath路径下的类包，主要就是加载你自己写

的那些类

##### 自定义加载器

负责加载用户自定义路径下的类包

##### 自定义一个类加载器示例

自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，一个是

loadClass\(String, boolean\)，实现了**双亲委派机制**，大体逻辑

\1. 首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，

直接返回。

\2. 如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由

父加载器加载（即调用parent.loadClass\(name, false\);）.或者是调用bootstrap类加

载器来加载。

\3. 如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器

的findClass方法来完成类加载。

![](/assets/类加载.png)

这里类加载其实就有一个**双亲委派机制**，加载某个类时会先委托父加载器寻找目标类，找不 

到再委托上层父加载器加载，如果所有父加载器在自己的加载类路径下都找不到目标类，则 

在自己的类加载路径中查找并载入目标类。

#### 为什么要设计双亲委派机制？ 

##### 沙箱安全机制

自己写的java.lang.String.class类不会被加载，这样便可以防止 

核心API库被随意篡改 ，核心类库无法用自定义类加载器加载

##### 避免类的重复加载

当父亲已经加载了该类时，就没有必要子ClassLoader再加 

载一次，保证**被加载类的唯一性** 



**打破双亲委派** 

以Tomcat类加载为例，Tomcat 如果使用默认的双亲委派类加载机制行不行？ 

我们思考一下：Tomcat是个web容器， 那么它要解决什么问题： 

\1. 一个web容器可能需要部署两个应用程序，不同的应用程序可能会**依赖同一个第三方类** 

**库的不同版本**，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的 

类库都是独立的，保证相互隔离。 

\2. 部署在同一个web容器中**相同的类库相同的版本可以共享**。否则，如果服务器有10个应 

用程序，那么要有10份相同的类库加载进虚拟机。 

\3. **web容器也有自己依赖的类库，不能与应用程序的类库混淆**。基于安全考虑，应该让容 

器的类库和程序的类库隔离开来。 

\4. web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟 

机中运行，但程序运行后修改jsp已经是司空见惯的事情， web容器需要支持 jsp 修改后不 

用重启。 

##### Tomcat 如果使用默认的双亲委派类加载机制行不行？ 

答案是不行的。为什么？第一个问题，如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的， 

默认的类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。第二个问 

题，默认的类加载器是能够实现的，因为他的职责就是保证**唯一性**。 

第三个问题和第一个问题一样。 

我们再看第四个问题，我们想我们要怎么实现jsp文件的热加载，jsp 文件其实也就是class 

文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后 

的jsp是不会重新加载的。那么怎么办呢？我们可以直接卸载掉这jsp文件的类加载器，所以 

你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载 

这个jsp类加载器。重新创建类加载器，重新加载jsp文件。 