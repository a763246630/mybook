# 类加载机制

### 类加载过程

类加载到使用整个过程有如下几步：

**加载 &gt;&gt; 验证 &gt;&gt; 准备 &gt;&gt; 解析 &gt;&gt; 初始化 &gt;&gt;** 使用 &gt;&gt; 卸载

#### 加载

在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用

类的main\(\)方法，new对象等等

#### 验证

校验字节码文件的正确性

#### 准备

给类的静态变量分配内存，并赋予默认值 （例如对象赋值为null，int类型为0）

#### 解析

将符号引用替换为直接引用，该阶段会把一些静态方法\(符号引用，比如

main\(\)方法\)替换为指向数据所存内存的指针或句柄等\(直接引用\)，这是所谓的**静态链**

**接**过程\(类加载期间完成\)，**动态链接**是在程序运行期间完成的将符号引用替换为直接

引用。

#### 初始化

对类的静态变量初始化为指定的值，执行静态代码块

#### **类加载器和双亲委派机制**

上面的类加载过程主要是通过类加载器来实现的，Java里有如下几种类加载器

自上而下加载类，自下而上查询类是否加载。

vm option 加上参数 -verbose:class 打印类加载信息

##### 启动类加载   jvm.dll c语言去加载

负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如 rt.jar、charsets.jar等

##### 扩展类加载器

负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中

的JAR类包

##### 应用程序类加载器

负责加载ClassPath路径下的类包，主要就是加载你自己写

的那些类

##### 自定义加载器

负责加载用户自定义路径下的类包

##### 自定义一个类加载器示例

自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，一个是

loadClass\(String, boolean\)，实现了**双亲委派机制**，大体逻辑

\1. 首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，

直接返回。

\2. 如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由

父加载器加载（即调用parent.loadClass\(name, false\);）.或者是调用bootstrap类加

载器来加载。

\3. 如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器

的findClass方法来完成类加载。

![](/assets/类加载.png)

这里类加载其实就有一个**双亲委派机制**，加载某个类时会先委托父加载器寻找目标类，找不

到再委托上层父加载器加载，如果所有父加载器在自己的加载类路径下都找不到目标类，则

在自己的类加载路径中查找并载入目标类。

#### 为什么要设计双亲委派机制？

##### 沙箱安全机制

自己写的java.lang.String.class类不会被加载，这样便可以防止

核心API库被随意篡改 ，核心类库无法用自定义类加载器加载

##### 避免类的重复加载

当父亲已经加载了该类时，就没有必要子ClassLoader再加

载一次，保证**被加载类的唯一性**

**打破双亲委派**

以Tomcat类加载为例，Tomcat 如果使用默认的双亲委派类加载机制行不行？

我们思考一下：Tomcat是个web容器， 那么它要解决什么问题：

\1. 一个web容器可能需要部署两个应用程序，不同的应用程序可能会**依赖同一个第三方类**

**库的不同版本**，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的

类库都是独立的，保证相互隔离。

\2. 部署在同一个web容器中**相同的类库相同的版本可以共享**。否则，如果服务器有10个应

用程序，那么要有10份相同的类库加载进虚拟机。

\3. **web容器也有自己依赖的类库，不能与应用程序的类库混淆**。基于安全考虑，应该让容

器的类库和程序的类库隔离开来。

\4. web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟

机中运行，但程序运行后修改jsp已经是司空见惯的事情， web容器需要支持 jsp 修改后不

用重启。

##### Tomcat 如果使用默认的双亲委派类加载机制行不行？

答案是不行的。为什么？第一个问题，如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，

默认的类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。第二个问

题，默认的类加载器是能够实现的，因为他的职责就是保证**唯一性**。

第三个问题和第一个问题一样。

我们再看第四个问题，我们想我们要怎么实现jsp文件的热加载，jsp 文件其实也就是class

文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后

的jsp是不会重新加载的。那么怎么办呢？我们可以直接卸载掉这jsp文件的类加载器，所以

你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载

这个jsp类加载器。重新创建类加载器，重新加载jsp文件。

![](/assets/类加载3.png)

tomcat的几个主要类加载器： 

commonLoader：Tomcat最基本的类加载器，加载路径中的class可以被 

Tomcat容器本身以及各个Webapp访问； 

catalinaLoader：Tomcat容器私有的类加载器，加载路径中的class对于 

Webapp不可见； 

sharedLoader：各个Webapp共享的类加载器，加载路径中的class对于所有 

Webapp可见，但是对于Tomcat容器不可见； 

WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对 

当前Webapp可见；从图中的委派关系中可以看出： 

CommonClassLoader能加载的类都可以被CatalinaClassLoader和SharedClassLoader使 

用，从而实现了公有类库的共用，而CatalinaClassLoader和SharedClassLoader自己能加 

载的类则与对方相互隔离。 

WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个 

WebAppClassLoader实例之间相互隔离。 

而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，它出现的 

目的就是为了被丢弃：当Web容器检测到JSP文件被修改时，会替换掉目前的 

JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的热加载功能。 

tomcat 这种类加载机制违背了java 推荐的双亲委派模型了吗？答案是：违背了。 

我们前面说过，双亲委派机制要求除了顶层的启动类加载器之外，其余的类加载器都应当由 

自己的父类加载器加载。 

很显然，tomcat 不是这样实现，tomcat 为了实现隔离性，没有遵守这个约定，**每个** 

**webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器，打破了双** 

**亲委派机制**。