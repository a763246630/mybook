## 常见的并发问题和解决并发问题的锁

#### 常见的并发问题

1.多个线程同时去修改一个共享变量时造成数据错乱;

2.先查询判断数据不存在再添加，多个线程同时去查询的时候都是不存在所以造成插入重复数据;

3.并发请求同一个业务造成业务重复执行如用户账户余额增加或减少多次执行；

#### 常见的锁

服务级锁（JVM级）

Lock 

synchronized

ReentrantLock

数据库锁

乐观锁

利用版本号或数据修改之前查询的状态作为更新条件（原理查询修改之前的数据版本号，跟修改时的数据版本号对比相同则更新，如果相同则代表数据没有被其他线程修改过。）

悲观锁

业务开始时先用for update 锁住要修改的行，修改完再释放for update

应用级锁（全局锁）

redis锁

setnx

zookeeper锁

创建一个持久化有序节点

在节点下再每个线程创建临时有序节点，判断当前节点是不是最小节点，是最小节点则获取到锁

##### Syncronized锁的膨胀 无锁->偏向锁->轻量级锁->重量级锁

无锁状态到偏向锁

无锁状态：线程获取到锁做了一个无锁标记；

如果有其他线程竞争(当)则膨胀到偏向锁；



