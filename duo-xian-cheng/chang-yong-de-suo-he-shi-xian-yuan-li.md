## 常见的并发问题和解决并发问题的锁

#### 常见的并发问题

1.多个线程同时去修改一个共享变量时造成数据错乱;

2.先查询判断数据不存在再添加，多个线程同时去查询的时候都是不存在所以造成插入重复数据;

3.并发请求同一个业务造成业务重复执行如用户账户余额增加或减少多次执行；

#### 常见的锁

服务级锁（JVM级）

Lock

synchronized

ReentrantLock

数据库锁

乐观锁

利用版本号或数据修改之前查询的状态作为更新条件（原理查询修改之前的数据版本号，跟修改时的数据版本号对比相同则更新，如果相同则代表数据没有被其他线程修改过。）

悲观锁

业务开始时先用for update 锁住要修改的行，修改完再释放for update

应用级锁（全局锁）

redis锁

setnx

zookeeper锁

创建一个持久化有序节点

在节点下再每个线程创建临时有序节点，判断当前节点是不是最小节点，是最小节点则获取到锁

### Syncronized JVM内置锁 原理

synchronized内置锁是一种对象锁\(锁的是对象而非引用\)，作用粒度是对象，可以用来实现对临界资源的同步互斥访问，是可重入的。

加锁的方式：

同步实例方法，锁是当前实例对象

同步类方法，锁是当前类对象

同步代码块，锁是括号里面的对象

synchronized是基于JVM内置锁实现，通过内部对象Monitor\(监视器锁\)实现，基于进入与退出Monitor对象实现方法与代码块同步，监视器锁的实现依赖 底层操作系统的Mutex lock（互斥锁）实现，它是一个重量级锁性能较低（在java1.5及以前）。JVM内置锁在1.5之后版本做了重大的优化，如锁粗化（Lock Coarsening）、锁消除（Lock Elimination）、轻量级（Lightweight Locking）、偏向锁（Biased Locking）、适应性自旋（Adaptive Spinning）等 技术来减少锁操作的开销，，内置锁的并发性能已经基本与Lock持平。

synchronized关键字被编译成字节码后会被翻译成monitorenter 和 monitorexit 两条指令分别在同步块逻辑代码的起始位置与结束位置。

![](/assets/sync1.png)

每个同步对象都有一个自己的Monitor\(监视器锁\)，加锁过程如下图所示：

##### ![](/assets/sync2.png)

锁状态是被记录在每个对象的对象头（Mark Word）

##### 对象的内存布局

HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：

对象头（Header）：比如 hash码，对象所属的年代，对象锁，锁状态标志，偏向锁（线程）ID，偏向时间，数组长度（数组对象）等

实例数据（Instance Data）：即创建对象时，对象中成员变量，方法等

对齐填充（Padding）：对象的大小必须是8字节的整数倍

![](/assets/sync3.png)

对象头

HotSpot虚拟机的对象头包括两部分信息，第一部分是“Mark Word”，用于存储对象自身的运行时数据， 如**哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳**等等，这部分数据的长度在32位和64位的虚拟机（暂 不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为“Mark Word”。对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额 外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机 中对象未被锁定的状态下，MarkWord的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志 位，1Bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示。



但是如果对象是数组类型，则需要三个机器码，因为JVM虚拟机可以通过 

Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数 

组的大小，所以用一块来记录数组长度。 

对象头信息是与对象自身定义的数据无关的额外存储成本，但是考虑到虚拟 

机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内 

存存储尽量多的数据，它会根据对象的状态复用自己的存储空间，也就是说， 

Mark Word会随着程序的运行发生变化，变化状态如下（32位虚拟机）：

##### Syncronized锁的膨胀 无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁

无锁状态到偏向锁

无锁状态：线程获取到锁做了一个无锁标记；

如果有其他线程竞争\(当\)则膨胀到偏向锁；

