**二叉树**

* 所有非叶子结点\(叶子节点是指没有子节点的节点\)至多拥有两个儿子

* 所有结点存储一个关键字

* 非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树

![](/assets/btree1.png)

​     二叉搜索树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；

否则，如果查询关键字比结点关键字小，就进入左子节点；如果比结点关键字大，就进入

右子节点；如果左子节点或右子节点的指针为空，则报告找不到相应的关键字；

​       如果二叉搜索树的所有非叶子节点的左右子节点数目均保持差不多（平衡），那么B树

的搜索性能逼近二分查找；

​        它比连续内存空间的二分查找的优点是，改变二叉搜索树结构时（插入与删除结点）不需要移动大段的内存

数据，甚至通常是常数开销；

![](/assets/btree2.png)

 但二叉搜索树在经过多次插入与删除后，有可能导致不同的结构：

![](/assets/btree3.png)

  右边也是一个二叉搜索树，但它的搜索性能已经是线性的了；同样的关键字集合有可能导致不同的

树结构索引；所以，使用二叉搜索树还要考虑尽可能让B树保持左图的结构，和避免右图的结构，也就

是所谓的“平衡”问题；      

​       实际使用的二叉搜索树都是在原二叉搜索树的基础上加上平衡算法，即“平衡二叉树”；如何保持B树

结点分布均匀的平衡算法是平衡二叉树的关键；平衡算法是一种在二叉搜索树中插入和删除结点的

策略；

**B 树**可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。

* 根节点至少有两个子节点
* 每个节点有M-1个key，并且以升序排列
* 位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间
* 其它节点至少有M/2个子节点

下图是一个M=4 阶的B树:

[![](https://images0.cnblogs.com/blog/94031/201403/290047064066682.png "B tree")](https://images0.cnblogs.com/blog/94031/201403/290047034539184.png)



B树对比红黑树