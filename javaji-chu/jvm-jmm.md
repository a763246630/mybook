### JMM

JMM（Java Memory Model）即java内存模型

了解jvm内存模型前，了解下cpu和计算机内存的交互情况。【因为Java虚拟机内存模型定义的访问操作与计算机十分相似】

#### CPU和内存的交互

在计算机中，cpu和内存的交互最为频繁，相比内存，磁盘读写太慢，内存相当于高速的缓冲区。

但是随着cpu的发展，内存的读写速度也远远赶不上cpu。因此cpu厂商在每颗cpu上加上高速缓存，用于缓解这种情况。现在cpu和内存的交互大致如下。

![](/assets/jvm1.png)

cpu上加入了高速缓存这样做解决了处理器和内存的矛盾\(一快一慢\)，但是引来的新的问题 - **缓存一致性**

在多核cpu中，每个处理器都有各自的高速缓存，而主内存确只有一个 。

```
CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找，每个cpu有且只有一套自己的缓存。
```

如何保证多个处理器运算涉及到同一个内存区域时，多线程场景下会存在缓存一致性问题，那么运行时保证数据一致性？

为了解决这个问题，各个处理器需遵循一些协议保证一致性。【如MSI，MESI协议。。】java采用volatile实现变量共享

![](/assets/jvm3.png)

#### 缓存一致性协议





![](/assets/jvm11.png)

#### 主内存

共享内存

#### 工作内存（高速缓存）

线程隔离

#### JMM-同步八种操作介绍

（1）**lock\(锁定\)**：作用于主内存的变量，把一个变量标记为一条线程独占状态

（2）**unlock\(解锁\)**：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的

变量才可以被其他线程锁定

（3）**read\(读取\)**：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，

以便随后的load动作使用

（4）**load\(载入\)**：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作

内存的变量副本中

（5）**use\(使用\)**：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎

（6）**assign\(赋值\)**：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存

的变量

（7）**store\(存储\)**：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，

以便随后的write的操作

（8）**write\(写入\)**：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送

到主内存的变量中

如果要把一个变量从主内存中复制到工作内存中，就需要按顺序地执行read和load操作，

如果把变量从工作内存中同步到主内存中，就需要按顺序地执行store和write操作。但Java内

存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。

### JVM

#### 堆

先进先出

存储对象的实例

#### 栈

先进后出

存储对象的引用 指向对象的实例的地址

#### 程序计数器

#### 方法区

#### 常量池



