# GC和JVM

[TOC]

java  gc主要是对堆内存和方法区空间的清理（回收没有引用的对象（无GCROOT根引用））。

### 堆内存对象分布结构

![](/assets/内存分布.png)

##### 堆内存主要分为Eden（新生代），两个Survivor区（to,from）（年轻代包含新生代）,old区（ 老年代）

##### minor GC（young GC）年轻代GC清理年轻代内存空间（回收无引用的对象）

##### full GC（Major GC）一般会回收老年代，年轻代，方法区的垃圾， Major GC的速度一般会比Minor GC的慢10倍以上。

##### 对象gc轮转过程

新创建的对象会放入Eden（伊甸园区）伊甸园区放满会发生minorGC，发生gc会将Eden区存活对象放入Survivor区from，再次发生GC将Eden区和Survivor区from存活对象放入to区。**Survivor不够用直接放入老年代，** 15次GC没有回收的对象会移到老年代，老年代满了会发生fullGC

jvm内存设置案例

日均百万级订单交易系统如何设置JVM参数

![](/assets/ty1.png)

一天百万级订单这个绝对是现在顶尖电商公司交易量级，对于这种量级的系统我们该如何设置JVM参数了？

我们可以试着估算下，其实日均百万订单主要也就是集中在当日的几个小时生成的，我们假设是三小时，也就是每秒大概生成100单左

右。

这种系统我们一般至少要三四台机器去支撑，假设我们部署了四台机器，也就是每台每秒钟大概处理完成25单左右，往上毛估每秒处理**30** 单吧。

双核4G 3台 集群（系统占1G多，方法区分配完，堆最多分配1G多，新生代3分之1占600M\(Eden区8/10 占）每秒100单（480秒发生一次minorGC）可以接受，但是大促时（假设扩大20倍，每秒产生20M对象，24秒就发生一次minorGC） 过于频繁（而且资源（IO，CPU）被占完订单处理会变慢（垃圾对象很可能几十秒还清理，会进入老年代，老年代放满会出现fullGC导致STW），所以要避免资源被占满，预估订单量会变大时适当扩大机器配置（4核8G））。

#### STW（stop the world）

当虚拟机完成两次标记后，便确认了可以回收的对象。但是，**垃圾回收并不会阻塞我们程序的线程，他是与当前程序并发执行的**。所以问题就出在这里，**当GC线程标记好了一个对象的时候，此时我们程序的线程又将该对象重新加入了“关系网”中，当执行二次标记的时候，该对象也没有重写finalize\(\)方法，因此回收的时候就会回收这个不该回收的对象。**   
  **虚拟机的解决方法就是在一些特定指令位置设置一些“安全点”，当程序运行到这些“安全点”的时候就会暂停所有当前运行的线程（Stop The World 所以叫STW），暂停后再找到“GC Roots”进行关系的组建，进而执行标记和清除。**

这些特定的指令**（安全点）位置主要在**：

* 1、循环的末尾
* 2、方法临返回前 / 调用方法的call指令后
* 3、可能抛异常的位置

找到“GC Roots”也是要花很长的时间，然而这里又有新的解决方法，就是通过**采用一个OopMap的数据结构来记录系统中存活的“GC Roots”**，**在类加载完成的时候，虚拟机就把对象内什么偏移量上是什么类型的数据计算出来保存在OopMap，通过解释OopMap就可以找到堆中的对象，这些对象就是GC Roots。而不需要一个一个的去判断某个内存位置的值是不是引用。这种方式也叫准确式GC**。   
  回到最开始的问题，那个**停顿类型就是STW**，至于**有GC和Full GC之分，还有Full GC \(System\)**。个人认为主要是Full GC时STW的时间相对GC来说时间很长，因为Full GC针对整个堆以及永久代的，因此整个GC的范围大大增加；还有就是他的回收算法就是我们之前说过的“标记–清除–整理”，这里也会损耗一定的时间。**所以我们在优化JVM的时候，减少Full GC的次数也是经常用到的办法。**

#### 对象进入老年代的情况

##### 1.大对象直接进入老年代，设置参数（多大的对象直接进老年代）：-XX:PretenureSizeThreshold=1000000单位kb（1M）

大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。JVM参数 -

XX:PretenureSizeThreshold 可以设置大对象的大小，如果对象超过设置大小

会直接进入老年代，不会进入年轻代，这个参数只在 Serial 和ParNew两个收集

器下有效。

比如设置JVM参数：-XX:PretenureSizeThreshold=1000000（10M） -

XX:+UseSerialGC ，再执行下上面的第一个程序会发现大对象直接进了老年代

**为什么要这样呢？**

为了避免为大对象分配内存时的复制操作而降低效率。

##### 2.长期存活的对象将进入老年代 \(通过参数 -XX:MaxTenuringThreshold 来设置。\)

既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪

些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每

个对象一个对象年龄（Age）计数器。

如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被

Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1。对象

在 Survivor 中每熬过一次 MinorGC，年龄就增加1岁，当它的年龄增加到一定

程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈

值.

##### 3.Minor gc后存活的对象Survivor区放不下

这种情况会把存活的对象部分挪到老年代，部分可能还会放在Survivor区

##### 4.对象动态年龄判断机制

当前放对象的Survivor区域里\(其中一块区域，放对象的那块s区\)，一批对象的总

大小大于这块Survivor区域内存大小的50%，那么此时**大于等于**这批对象年龄最

大值的对象，就可以直接进入老年代了，例如Survivor区域里现在有一批对象，

年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就

会把年龄n以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活

的对象，尽早进入老年代。对象动态年龄判断机制一般是在minor gc之后触发

的。

#### 发生minorGC之前需要判断，老年代空间分配担保机制

年轻代每次**minor gc**之前JVM都会计算下老年代**剩余可用空间**

如果这个可用空间小于年轻代里现有的所有对象大小之和\(**包括垃圾对象**\)

就会看一个“-XX:-HandlePromotionFailure”\(jdk1.8默认就设置了\)的参数是

否设置了

如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次minor

gc后进入老年代的对象的**平均大小**。

如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full

gc，对老年代和年轻代一起回收一次垃圾，如果回收完还是没有足够空间存放

新的对象就会发生"OOM"

当然，如果minor gc之后剩余存活的需要挪动到老年代的对象大小还是大于老

年代可用空间，那么也会触发full gc，full gc完之后如果还是没用空间放minor

gc之后的存活对象，则也会发生“OOM”

![](/assets/kjdbjz.png)

#### Eden与Survivor区默认8:1:1 ，可能发生自动变化

大量的对象被分配在eden区，eden区满了后会触发minor gc，可能会有99% 

以上的对象成为垃圾被回收掉，剩余存活的对象会被挪到为空的那块survivor 

区，下一次eden区满了后又会触发minor gc，把eden区和survivor去垃圾对象 

回收，把剩余存活的对象一次性挪动到另外一块为空的survivor区，因为新生代 

的对象都是朝生夕死的，存活时间很短，所以JVM默认的8:1:1的比例是很合适 

的，**让eden区尽量的大，survivor区够用即可** 

JVM默认有这个参数-XX:+UseAdaptiveSizePolicy，会导致这个比例自动变 

化，如果不想这个比例有变化可以设置参数-XX:-UseAdaptiveSizePolicy 



#### 如何判断对象可以被回收

堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已 

经死亡（即不能再被任何途径使用的对象）。 

##### 1.引用计数法会导致内存泄露

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用 

失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。**这个方法实现简单，效率高，但是目**

**前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问**

**题。** 所谓对 象之间的相互引用问题，如下面代码所示：除了对象objA 和 objB 相互引用着 

对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它 

们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们,会导致内存泄露。 

```
public class ReferenceCountingGc {
Object instance = null; 
public static void main(String[] args) {
ReferenceCountingGc objA = new ReferenceCountingGc();
ReferenceCountingGc objB = new ReferenceCountingGc();
objA.instance = objB;
objB.instance = objA; 
objA = null;
objB = null;  
} }
```

##### 2.可达性分析算法

这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点， 

从这些节点开始向下搜索，找到的对象都标记为非垃圾对象，其余未标记的对象 

都是垃圾对象 

**GC Roots**根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等

特指的是垃圾收集器（Garbage Collector）的对象，GC会收集那些不是GC roots且没有被GC roots引用的对象。

一个对象可以属于多个root，GC root有几下种：

- **Class** - 由系统类加载器(system class loader)加载的对象，这些类是不能够被回收的，他们可以以静态字段的方式保存持有其它对象。我们需要注意的一点就是，通过用户自定义的类加载器加载的类，除非相应的`java.lang.Class`实例以其它的某种（或多种）方式成为roots，否则它们并不是roots，.
- **Thread** - 活着的线程
- **Stack Local** - Java方法的local变量或参数
- **JNI Local** - JNI方法的local变量或参数
- **JNI Global** - 全局JNI引用
- **Monitor Used** - 用于同步的监控对象
- **Held by JVM** - 用于JVM特殊目的由GC保留的对象，但实际上这个与JVM的实现是有关的。可能已知的一些类型是：系统类加载器、一些JVM知道的重要的异常类、一些用于处理异常的预分配对象以及一些自定义的类加载器等。**然而，JVM并没有为这些对象提供其它的信息，因此就只有留给分析分员去确定哪些是属于"JVM持有"的了**

##### 3.常见引用类型 （软引用，弱引用，虚引用有引用也可能回收）

java的引用类型一般分为四种：**强引用**、**软引用**、弱引用、虚引用 

**强引用**：普通的变量引用 

1 public static User user = new User(); 

**软引用**：将对象用SoftReference软引用类型的对象包裹，正常情况不会被回 

收，但是GC做完后发现释放不出空间存放新的对象，则会把这些软引用的对象 

回收掉。**软引用可用来实现内存敏感的高速缓存。** 1 public static SoftReference<User> user = new SoftReference<User>(new 

User()); 

软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时 

显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略 

了。

（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过 

的页面时，需要重新构建 

（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内 

存溢出 

**弱引用**：将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差 

不多，**GC会直接回收掉**，很少用 1 public static WeakReference<User> user = new WeakReference<User>(new 

User());

**虚引用：**GC会直接回收掉,虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎 

不用

##### 4.finalize()方法最终判定对象是否存活

即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们 

暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。 

**标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。** 

**1. 第一次标记并进行一次筛选。** 

筛选的条件是此对象是否有必要执行finalize()方法。 

当对象没有覆盖finalize方法，对象将直接被回收。 

**2. 第二次标记** 

如果这个对象覆盖了finalize方法，finalize方法是对象脱逃死亡命运的最后一次 

机会，如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何的一 

个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第 

二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本 

上它就真的被回收了。 

```
public class OOMTest { 
 public static void main(String[] args) { 
 List<Object> list = new ArrayList<>(); 
 int i = 0; 
 int j = 0; 
 while (true) { 
 list.add(new User(i++, UUID.randomUUID().toString())); 
 new User(j‐‐, UUID.randomUUID().toString()); 
 } 
 } 
 }
```

##### 如何判断一个类是无用的类

方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？ 

类需要同时满足下面3个条件才能算是 **“无用的类”** ：该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何 

实例。

加载该类的 ClassLoader 已经被回收。 

该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何 

地方通过反射访问该类的方法。 



#### jvm内存分配参数设置

##### 堆大小设置  初始堆大小 -Xms100M  最大堆大小   -Xmx100M

##### 设置年轻代大小 -Xmn 100M

##### 设置年轻代比例 -XX:SurvivorRatio=8:1:1  年轻代默认比例为Eden:to:from\(8:1:1

##### 设置元空间大 初始-XX:MetaspaceSize=8m  最大-XX:MaxMetaspaceSize=50m

##### 设置年轻代和年老代的比值 默认-XX:NewRatio=1:2

##### 设置打印GC信息 -XX:+PrintGCDetails

#### 内存调优工具

##### jps

查看java进程

jmap

jmap heap 30080\(端口号\)

##### Jinfo

查看jvm的运行时参数  jinfo -flags 30880\(端口号\)

查看正在运行的Java应用程序的扩展参数  jinfo -sysprop 30880\(端口号\)



#### 垃圾回收算法

标记清除算法

算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完 成后统一回收所有被标记的对象。它是最基础的收集算法，效率也很高，但是会 带来两个明显的问题： 1. 效率问题 2. 空间问题（标记清除后会产生大量不连续的碎片）



复制清除算法

垃圾回收器

