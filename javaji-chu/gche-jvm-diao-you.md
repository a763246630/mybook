# GC和JVM

java  gc主要是对堆内存和方法区空间的清理（回收没有引用的对象（无GCROOT根引用））。

### 堆内存对象分布结构

![](/assets/内存分布.png)

##### 堆内存主要分为Eden（新生代），两个Survivor区（to,from）（年轻代包含新生代）,old区（ 老年代）

##### minor GC（young GC）年轻代GC清理年轻代内存空间（回收无引用的对象）

##### full GC（Major GC）一般会回收老年代，年轻代，方法区的垃圾， Major GC的速度一般会比Minor GC的慢10倍以上。

##### 对象gc轮转过程

新创建的对象会放入Eden（伊甸园区）伊甸园区放满会发生minorGC，发生gc会将Eden区存活对象放入Survivor区from，再次发生GC将Eden区和Survivor区from存活对象放入to区。**Survivor不够用直接放入老年代，** 15次GC没有回收的对象会移到老年代，老年代满了会发生fullGC

jvm内存设置案例

日均百万级订单交易系统如何设置JVM参数

![](/assets/ty1.png)

一天百万级订单这个绝对是现在顶尖电商公司交易量级，对于这种量级的系统我们该如何设置JVM参数了？ 

我们可以试着估算下，其实日均百万订单主要也就是集中在当日的几个小时生成的，我们假设是三小时，也就是每秒大概生成100单左 

右。

这种系统我们一般至少要三四台机器去支撑，假设我们部署了四台机器，也就是每台每秒钟大概处理完成25单左右，往上毛估每秒处理**30** 单吧。

双核4G 3台 集群（系统占1G多，方法区分配完，堆最多分配1G多，新生代3分之1占600M(Eden区8/10 占）每秒100单（480秒发生一次minorGC）可以接受，但是大促时（假设扩大20倍，每秒产生20M对象，24秒就发生一次minorGC） 过于频繁（而且资源（IO，CPU）被占完订单处理会变慢（垃圾对象很可能几十秒还清理，会进入老年代，老年代放满会出现fullGC导致STW），所以要避免资源被占满，预估订单量会变大时适当扩大机器配置（4核8G））。

#### STW（stop the world）

当虚拟机完成两次标记后，便确认了可以回收的对象。但是，**垃圾回收并不会阻塞我们程序的线程，他是与当前程序并发执行的**。所以问题就出在这里，**当GC线程标记好了一个对象的时候，此时我们程序的线程又将该对象重新加入了“关系网”中，当执行二次标记的时候，该对象也没有重写finalize()方法，因此回收的时候就会回收这个不该回收的对象。** 
  **虚拟机的解决方法就是在一些特定指令位置设置一些“安全点”，当程序运行到这些“安全点”的时候就会暂停所有当前运行的线程（Stop The World 所以叫STW），暂停后再找到“GC Roots”进行关系的组建，进而执行标记和清除。** 


  这些特定的指令**（安全点）位置主要在**：

- 1、循环的末尾
- 2、方法临返回前 / 调用方法的call指令后
- 3、可能抛异常的位置

  找到“GC Roots”也是要花很长的时间，然而这里又有新的解决方法，就是通过**采用一个OopMap的数据结构来记录系统中存活的“GC Roots”**，**在类加载完成的时候，虚拟机就把对象内什么偏移量上是什么类型的数据计算出来保存在OopMap，通过解释OopMap就可以找到堆中的对象，这些对象就是GC Roots。而不需要一个一个的去判断某个内存位置的值是不是引用。这种方式也叫准确式GC**。 
  回到最开始的问题，那个**停顿类型就是STW**，至于**有GC和Full GC之分，还有Full GC (System)**。个人认为主要是Full GC时STW的时间相对GC来说时间很长，因为Full GC针对整个堆以及永久代的，因此整个GC的范围大大增加；还有就是他的回收算法就是我们之前说过的“标记–清除–整理”，这里也会损耗一定的时间。**所以我们在优化JVM的时候，减少Full GC的次数也是经常用到的办法。**

#### 对象进入老年代的情况

##### 1.大对象直接进入老年代，设置参数（多大的对象直接进老年代）：-XX:PretenureSizeThreshold=1000000单位kb（1M）

大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。JVM参数 - 

XX:PretenureSizeThreshold 可以设置大对象的大小，如果对象超过设置大小 

会直接进入老年代，不会进入年轻代，这个参数只在 Serial 和ParNew两个收集 

器下有效。 

比如设置JVM参数：-XX:PretenureSizeThreshold=1000000（10M） - 

XX:+UseSerialGC ，再执行下上面的第一个程序会发现大对象直接进了老年代 

**为什么要这样呢？** 

为了避免为大对象分配内存时的复制操作而降低效率。

##### 2.长期存活的对象将进入老年代 (通过参数 -XX:MaxTenuringThreshold 来设置。)

既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪 

些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每 

个对象一个对象年龄（Age）计数器。 

如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 

Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1。对象 

在 Survivor 中每熬过一次 MinorGC，年龄就增加1岁，当它的年龄增加到一定 

程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈 

值.

##### 3.Minor gc后存活的对象Survivor区放不下 

这种情况会把存活的对象部分挪到老年代，部分可能还会放在Survivor区

##### 4.对象动态年龄判断机制

当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总 

大小大于这块Survivor区域内存大小的50%，那么此时**大于等于**这批对象年龄最 

大值的对象，就可以直接进入老年代了，例如Survivor区域里现在有一批对象， 

年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就 

会把年龄n以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活 

的对象，尽早进入老年代。对象动态年龄判断机制一般是在minor gc之后触发 

的。









#### jvm内存分配参数设置

##### 堆大小设置  初始堆大小 -Xms100M  最大堆大小   -Xmx100M

##### 设置年轻代大小 -Xmn 100M

##### 设置年轻代比例 -XX:SurvivorRatio=8:1:1  年轻代默认比例为Eden:to:from\(8:1:1

##### 设置元空间大 初始-XX:MetaspaceSize=8m  最大-XX:MaxMetaspaceSize=50m

##### 设置年轻代和年老代的比值 默认-XX:NewRatio=1:2

##### 设置打印GC信息 -XX:+PrintGCDetails



#### 内存调优工具

##### jps

查看java进程

jmap

jmap heap 30080(端口号)



**Jinfo**

查看jvm的运行时参数  jinfo -flags 30880\(端口号\)

查看正在运行的Java应用程序的扩展参数  jinfo -sysprop 30880\(端口号\)

