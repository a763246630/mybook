# GC和JVM

java  gc主要是对堆内存和方法区空间的清理（回收没有引用的对象（无GCROOT根引用））。

### 堆内存对象分布结构

![](/assets/内存分布.png)

##### 堆内存主要分为Eden（新生代），两个Survivor区（to,from）（年轻代包含新生代）,old区（ 老年代）

##### 堆大小设置  初始堆大小 -Xms100M  最大堆大小   -Xmx100M

##### 设置年轻代大小 -Xmn 100M

##### 设置年轻代比例 -XX:SurvivorRatio=8:1:1  年轻代默认比例为Eden:to:from\(8:1:1

##### 设置元空间大 初始-XX:MetaspaceSize=8m  最大-XX:MaxMetaspaceSize=50m

##### 设置年轻代和年老代的比值 默认-XX:NewRatio=1:2

##### 设置打印GC信息 -XX:+PrintGCDetails

##### minor GC（young GC）年轻代GC清理年轻代内存空间（回收无引用的对象）

##### full GC（Major GC）一般会回收老年代，年轻代，方法区的垃圾， Major GC的速度一般会比Minor GC的慢10倍以上。

##### 对象gc轮转过程

新创建的对象会放入Eden（伊甸园区）伊甸园区放满会发生minorGC，发生gc会将Eden区存活对象放入Survivor区from，再次发生GC将Eden区和Survivor区from存活对象放入to区。**Survivor不够用直接放入老年代，** 15次GC没有回收的对象会移到老年代，老年代满了会发生fullGC

jvm内存设置案例

日均百万级订单交易系统如何设置JVM参数

![](/assets/ty1.png)

一天百万级订单这个绝对是现在顶尖电商公司交易量级，对于这种量级的系统我们该如何设置JVM参数了？ 

我们可以试着估算下，其实日均百万订单主要也就是集中在当日的几个小时生成的，我们假设是三小时，也就是每秒大概生成100单左 

右。

这种系统我们一般至少要三四台机器去支撑，假设我们部署了四台机器，也就是每台每秒钟大概处理完成25单左右，往上毛估每秒处理**30** 单吧。

双核4G 3台 集群（系统占1G多，方法区分配完，堆最多分配1G多，新生代3分之1占600M(Eden区8/10 占）每秒100单（480秒发生一次minorGC）可以接受，但是大促时（假设扩大20倍，每秒产生20M对象，24秒就发生一次minorGC） 过于频繁（而且资源（IO，CPU）被占完订单处理会变慢（垃圾对象很可能几十秒还清理，会进入老年代，老年代放满会出现fullGC导致STW），所以要避免资源被占满，预估订单量会变大时适当扩大机器配置（4核8G））。

STW（stop the world）



#### 内存调优工具

**Jinfo**

查看jvm的运行时参数  jinfo -flags 30880\(端口号\)

查看正在运行的Java应用程序的扩展参数  jinfo -sysprop 30880\(端口号\)

