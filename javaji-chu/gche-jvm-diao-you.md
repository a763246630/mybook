# GC和JVM

[TOC]

java  gc主要是对堆内存和方法区空间的清理（回收没有引用的对象（无GCROOT根引用））。

### 堆内存对象分布结构

![](D:/book/Import/mybook/javaji-chu/assets/%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.png)

##### 堆内存主要分为Eden（新生代），两个Survivor区（to,from）（年轻代包含新生代）,old区（ 老年代）

##### minor GC（young GC）年轻代GC清理年轻代内存空间（回收无引用的对象）

##### full GC（Major GC）一般会回收老年代，年轻代，方法区的垃圾， Major GC的速度一般会比Minor GC的慢10倍以上。

##### 对象gc轮转过程

新创建的对象会放入Eden（伊甸园区）伊甸园区放满会发生minorGC，发生gc会将Eden区存活对象放入Survivor区from，再次发生GC将Eden区和Survivor区from存活对象放入to区。**Survivor不够用直接放入老年代，** 15次GC没有回收的对象会移到老年代，老年代满了会发生fullGC

jvm内存设置案例

日均百万级订单交易系统如何设置JVM参数

![]()

一天百万级订单这个绝对是现在顶尖电商公司交易量级，对于这种量级的系统我们该如何设置JVM参数了？

我们可以试着估算下，其实日均百万订单主要也就是集中在当日的几个小时生成的，我们假设是三小时，也就是每秒大概生成100单左

右。

这种系统我们一般至少要三四台机器去支撑，假设我们部署了四台机器，也就是每台每秒钟大概处理完成25单左右，往上毛估每秒处理**30** 单吧。

双核4G 3台 集群（系统占1G多，方法区分配完，堆最多分配1G多，新生代3分之1占600M\(Eden区8/10 占）每秒100单（480秒发生一次minorGC）可以接受，但是大促时（假设扩大20倍，每秒产生20M对象，24秒就发生一次minorGC） 过于频繁（而且资源（IO，CPU）被占完订单处理会变慢（垃圾对象很可能几十秒还清理，会进入老年代，老年代放满会出现fullGC导致STW），所以要避免资源被占满，预估订单量会变大时适当扩大机器配置（4核8G））。

#### STW（stop the world）

当虚拟机完成两次标记后，便确认了可以回收的对象。但是，**垃圾回收并不会阻塞我们程序的线程，他是与当前程序并发执行的**。所以问题就出在这里，**当GC线程标记好了一个对象的时候，此时我们程序的线程又将该对象重新加入了“关系网”中，当执行二次标记的时候，该对象也没有重写finalize\(\)方法，因此回收的时候就会回收这个不该回收的对象。**   
  **虚拟机的解决方法就是在一些特定指令位置设置一些“安全点”，当程序运行到这些“安全点”的时候就会暂停所有当前运行的线程（Stop The World 所以叫STW），暂停后再找到“GC Roots”进行关系的组建，进而执行标记和清除。**

这些特定的指令**（安全点）位置主要在**：

- 1、循环的末尾
- 2、方法临返回前 / 调用方法的call指令后
- 3、可能抛异常的位置

找到“GC Roots”也是要花很长的时间，然而这里又有新的解决方法，就是通过**采用一个OopMap的数据结构来记录系统中存活的“GC Roots”**，**在类加载完成的时候，虚拟机就把对象内什么偏移量上是什么类型的数据计算出来保存在OopMap，通过解释OopMap就可以找到堆中的对象，这些对象就是GC Roots。而不需要一个一个的去判断某个内存位置的值是不是引用。这种方式也叫准确式GC**。   
  回到最开始的问题，那个**停顿类型就是STW**，至于**有GC和Full GC之分，还有Full GC \(System\)**。个人认为主要是Full GC时STW的时间相对GC来说时间很长，因为Full GC针对整个堆以及永久代的，因此整个GC的范围大大增加；还有就是他的回收算法就是我们之前说过的“标记–清除–整理”，这里也会损耗一定的时间。**所以我们在优化JVM的时候，减少Full GC的次数也是经常用到的办法。**

#### 对象进入老年代的情况

##### 1.大对象直接进入老年代，设置参数（多大的对象直接进老年代）：-XX:PretenureSizeThreshold=1000000单位kb（1M）

大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。JVM参数 -

XX:PretenureSizeThreshold 可以设置大对象的大小，如果对象超过设置大小

会直接进入老年代，不会进入年轻代，这个参数只在 Serial 和ParNew两个收集

器下有效。

比如设置JVM参数：-XX:PretenureSizeThreshold=1000000（10M） -

XX:+UseSerialGC ，再执行下上面的第一个程序会发现大对象直接进了老年代

**为什么要这样呢？**

为了避免为大对象分配内存时的复制操作而降低效率。

##### 2.长期存活的对象将进入老年代 \(通过参数 -XX:MaxTenuringThreshold 来设置。\)

既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪

些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每

个对象一个对象年龄（Age）计数器。

如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被

Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1。对象

在 Survivor 中每熬过一次 MinorGC，年龄就增加1岁，当它的年龄增加到一定

程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈

值.

##### 3.Minor gc后存活的对象Survivor区放不下

这种情况会把存活的对象部分挪到老年代，部分可能还会放在Survivor区

##### 4.对象动态年龄判断机制 -XX:TargetSurvivorRatio目标存活率，默认为50%

当前放对象的Survivor区域里\(其中一块区域，放对象的那块s区\)，一批对象的总

大小大于这块Survivor区域内存大小的50%，那么此时**大于等于**这批对象年龄最

大值的对象，就可以直接进入老年代了，例如Survivor区域里现在有一批对象，

年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就

会把年龄n以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活

的对象，尽早进入老年代。对象动态年龄判断机制一般是在minor gc之后触发

的。

#### 发生minorGC之前需要判断，老年代空间分配担保机制

年轻代每次**minor gc**之前JVM都会计算下老年代**剩余可用空间**

如果这个可用空间小于年轻代里现有的所有对象大小之和\(**包括垃圾对象**\)

就会看一个“-XX:-HandlePromotionFailure”\(jdk1.8默认就设置了\)的参数是

否设置了

如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次minor

gc后进入老年代的对象的**平均大小**。

如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full

gc，对老年代和年轻代一起回收一次垃圾，如果回收完还是没有足够空间存放

新的对象就会发生"OOM"

当然，如果minor gc之后剩余存活的需要挪动到老年代的对象大小还是大于老

年代可用空间，那么也会触发full gc，full gc完之后如果还是没用空间放minor

gc之后的存活对象，则也会发生“OOM”

![]()

#### Eden与Survivor区默认8:1:1 ，可能发生自动变化

大量的对象被分配在eden区，eden区满了后会触发minor gc，可能会有99% 

以上的对象成为垃圾被回收掉，剩余存活的对象会被挪到为空的那块survivor 

区，下一次eden区满了后又会触发minor gc，把eden区和survivor去垃圾对象 

回收，把剩余存活的对象一次性挪动到另外一块为空的survivor区，因为新生代 

的对象都是朝生夕死的，存活时间很短，所以JVM默认的8:1:1的比例是很合适 

的，**让eden区尽量的大，survivor区够用即可** 

JVM默认有这个参数-XX:+UseAdaptiveSizePolicy，会导致这个比例自动变 

化，如果不想这个比例有变化可以设置参数-XX:-UseAdaptiveSizePolicy 



#### 如何判断对象可以被回收

堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已 

经死亡（即不能再被任何途径使用的对象）。 

##### 1.引用计数法会导致内存泄露

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用 

失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。**这个方法实现简单，效率高，但是目**

**前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问**

**题。** 所谓对 象之间的相互引用问题，如下面代码所示：除了对象objA 和 objB 相互引用着 

对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它 

们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们,会导致内存泄露。 

```
public class ReferenceCountingGc {
Object instance = null; 
public static void main(String[] args) {
ReferenceCountingGc objA = new ReferenceCountingGc();
ReferenceCountingGc objB = new ReferenceCountingGc();
objA.instance = objB;
objB.instance = objA; 
objA = null;
objB = null;  
} }
```

##### 2.可达性分析算法

这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点， 

从这些节点开始向下搜索，找到的对象都标记为非垃圾对象，其余未标记的对象 

都是垃圾对象 

**GC Roots**根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等

特指的是垃圾收集器（Garbage Collector）的对象，GC会收集那些不是GC roots且没有被GC roots引用的对象。

一个对象可以属于多个root，GC root有几下种：

**Class** - 由系统类加载器(system class loader)加载的对象，这些类是不能够被回收的，他们可以以静态字段的方式保存持有其它对象。我们需要注意的一点就是，通过用户自定义的类加载器加载的类，除非相应的java.lang.Class实例以其它的某种（或多种）方式成为roots，否则它们并不是roots，.

**Thread** - 活着的线程

**Stack Local** - Java方法的local变量或参数

**JNI Local** - JNI方法的local变量或参数

**JNI Global** - 全局JNI引用

**Monitor Used** - 用于同步的监控对象

**Held by JVM** - 用于JVM特殊目的由GC保留的对象，但实际上这个与JVM的实现是有关的。可能已知的一些类型是：系统类加载器、一些JVM知道的重要的异常类、一些用于处理异常的预分配对象以及一些自定义的类加载器等。**然而，JVM并没有为这些对象提供其它的信息，因此就只有留给分析分员去确定哪些是属于"JVM持有"的了**

##### 3.常见引用类型 （软引用，弱引用，虚引用有引用也可能回收）

java的引用类型一般分为四种：**强引用**、**软引用**、弱引用、虚引用 

**强引用**：普通的变量引用 

1 public static User user = new User(); 

**软引用**：将对象用SoftReference软引用类型的对象包裹，正常情况不会被回 

收，但是GC做完后发现释放不出空间存放新的对象，则会把这些软引用的对象 

回收掉。**软引用可用来实现内存敏感的高速缓存。** 1 public static SoftReference<User> user = new SoftReference<User>(new 

User()); 

软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时 

显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略 

了。

（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过 

的页面时，需要重新构建 

（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内 

存溢出 

**弱引用**：将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差 

不多，**GC会直接回收掉**，很少用 1 public static WeakReference<User> user = new WeakReference<User>(new 

User());

**虚引用：**在java中用java.lang.ref.PhantomReference类表示。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。  虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

##### 4.finalize()方法最终判定对象是否存活

即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们 

暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。 

**标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。** 

**1. 第一次标记并进行一次筛选。** 

筛选的条件是此对象是否有必要执行finalize()方法。 

当对象没有覆盖finalize方法，对象将直接被回收。 

**2. 第二次标记** 

如果这个对象覆盖了finalize方法，finalize方法是对象脱逃死亡命运的最后一次 

机会，如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何的一 

个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第 

二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本 

上它就真的被回收了。 

```
public class OOMTest { 
 public static void main(String[] args) { 
 List<Object> list = new ArrayList<>(); 
 int i = 0; 
 int j = 0; 
 while (true) { 
 list.add(new User(i++, UUID.randomUUID().toString())); 
 new User(j‐‐, UUID.randomUUID().toString()); 
 } 
 } 
 }
```

##### 如何判断一个类是无用的类

方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？ 

类需要同时满足下面3个条件才能算是 **“无用的类”** ：该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何 

实例。

加载该类的 ClassLoader 已经被回收。 

该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何 

地方通过反射访问该类的方法。 



#### jvm内存分配参数设置

##### 堆大小设置  初始堆大小 -Xms100M  最大堆大小   -Xmx100M

##### 设置年轻代大小 -Xmn 100M

##### 设置年轻代比例 -XX:SurvivorRatio=8:1:1  年轻代默认比例为Eden:to:from\(8:1:1

##### 设置元空间大 初始-XX:MetaspaceSize=8m  最大-XX:MaxMetaspaceSize=50m

##### 设置年轻代和年老代的比值 默认-XX:NewRatio=1:2

##### 设置打印GC信息 -XX:+PrintGCDetails

#### 内存调优工具

##### jps

查看java进程

jmap -dump:format=b.file=aa.hprof

jmap -heap 30080\(端口号\)查看堆内存分配和使用情况

##### Jinfo

查看jvm的运行时参数  jinfo -flags 30880\(端口号\)

查看正在运行的Java应用程序的扩展参数  jinfo -sysprop 30880\(端口号\)

##### Jvisualvm 查看GC快照可视化工具

jvisualvm

-XX:HeapDumpPath=D:\jvm.dump

##### Jstack

jstack 20080(进程号) 查找死锁

**jstack**找出占用**cpu**最高的堆栈信息

1，使用命令top -p <pid> ，显示你的java进程的内存情况，pid是你的java进程号，比如4977 

2，按H，获取每个线程的内存情况 

3，找到内存和cpu占用最高的线程tid，比如4977 

4，转为十六进制得到 0x1371 ,此为线程id的十六进制表示5，执行 jstack 4977|grep -A 10 1371，得到线程堆栈信息中1371这个线程所在行的后面10行 

6，查看对应的堆栈信息找出可能存在问题的代码 

##### Jstat

jstat命令可以查看堆内存各部分的使用量

jstat [-命令选项] [vmid] [间隔时间(毫秒)] [查询次数] 

##### jstat -gc 20080（进程号）**最常用**，可以评估程序内存使用及GC压力整体情况 

S0C：第一个幸存区的大小 

S1C：第二个幸存区的大小 

S0U：第一个幸存区的使用大小 

S1U：第二个幸存区的使用大小 

EC：伊甸园区的大小 

EU：伊甸园区的使用大小 

OC：老年代大小 

OU：老年代使用大小 

MC：方法区大小(元空间) 

MU：方法区使用大小 

CCSC:压缩类空间大小 

CCSU:压缩类空间使用大小 

YGC：年轻代垃圾回收次数 

YGCT：年轻代垃圾回收消耗时间，单位sFGC：老年代垃圾回收次数 

FGCT：老年代垃圾回收消耗时间，单位s 

GCT：垃圾回收消耗总时间，单位s 

##### jstat -gccapacity 5268  堆内存统计

NGCMN：新生代最小容量 

NGCMX：新生代最大容量 

NGC：当前新生代容量 

S0C：第一个幸存区大小 

S1C：第二个幸存区的大小 

EC：伊甸园区的大小 

OGCMN：老年代最小容量 

OGCMX：老年代最大容量 

OGC：当前老年代大小 

OC:当前老年代大小 

MCMN:最小元数据容量 

MCMX：最大元数据容量 

MC：当前元数据空间大小 

CCSMN：最小压缩类空间大小 

CCSMX：最大压缩类空间大小 

CCSC：当前压缩类空间大小 

YGC：年轻代gc次数 

FGC：老年代GC次数

##### jstat -gcnew 5268 新生代垃圾回收统计 

S0C：第一个幸存区的大小 

S1C：第二个幸存区的大小 

S0U：第一个幸存区的使用大小 

S1U：第二个幸存区的使用大小 

TT:对象在新生代存活的次数 

MTT:对象在新生代存活的最大次数 

DSS:期望的幸存区大小 

EC：伊甸园区的大小 

EU：伊甸园区的使用大小 

YGC：年轻代垃圾回收次数 

YGCT：年轻代垃圾回收消耗时间 

##### jstat -gcnewcapacity 5268 新生代内存统计

NGCMN：新生代最小容量 

NGCMX：新生代最大容量 

NGC：当前新生代容量 

S0CMX：最大幸存1区大小 

S0C：当前幸存1区大小 

S1CMX：最大幸存2区大小 

S1C：当前幸存2区大小 

ECMX：最大伊甸园区大小 

EC：当前伊甸园区大小 

YGC：年轻代垃圾回收次数FGC：老年代回收次数 

##### jstat -gcold 5268 老年代垃圾回收统计 

MC：方法区大小 

MU：方法区使用大小 

CCSC:压缩类空间大小 

CCSU:压缩类空间使用大小 

OC：老年代大小 

OU：老年代使用大小 

YGC：年轻代垃圾回收次数 

FGC：老年代垃圾回收次数 

FGCT：老年代垃圾回收消耗时间 

GCT：垃圾回收消耗总时间 

##### jstat -gcoldcapacity 5268 老年代内存统计

OGCMN：老年代最小容量 

OGCMX：老年代最大容量 

OGC：当前老年代大小 

OC：老年代大小 

YGC：年轻代垃圾回收次数 

FGC：老年代垃圾回收次数 

FGCT：老年代垃圾回收消耗时间 

GCT：垃圾回收消耗总时间

##### jstat -gcmetacapacity 5268  元数据空间统计

MCMN:最小元数据容量 

MCMX：最大元数据容量 

MC：当前元数据空间大小 

CCSMN：最小压缩类空间大小 

CCSMX：最大压缩类空间大小 

CCSC：当前压缩类空间大小 

YGC：年轻代垃圾回收次数 

FGC：老年代垃圾回收次数 

FGCT：老年代垃圾回收消耗时间 

GCT：垃圾回收消耗总时间

##### jstat -gcutil 5268 

S0：幸存1区当前使用比例 

S1：幸存2区当前使用比例 

E：伊甸园区使用比例 

O：老年代使用比例 

M：元数据区使用比例 

CCS：压缩使用比例 

YGC：年轻代垃圾回收次数 

FGC：老年代垃圾回收次数 

FGCT：老年代垃圾回收消耗时间 

GCT：垃圾回收消耗总时间



**JVM运行情况预估** 

用 jstat gc -pid 命令可以计算出如下一些关键数据，有了这些数据就可以采用之前介绍过的优化思路，先给自己的系统设置一些初始性的 

JVM参数，比如堆内存大小，年轻代大小，Eden和Survivor的比例，老年代的大小，大对象的阈值，大龄对象进入老年代的阈值等。 

**年轻代对象增长的速率** 

可以执行命令 jstat -gc pid 1000 10 (每隔1秒执行1次命令，共执行10次)，通过观察EU(eden区的使用)来估算每秒eden大概新增多少对 

象，如果系统负载不高，可以把频率1秒换成1分钟，甚至10分钟来观察整体情况。注意，一般系统可能有高峰期和日常期，所以需要在不 

同的时间分别估算不同情况下对象增长速率。 

**Young GC的触发频率和每次耗时** 

知道年轻代对象增长速率我们就能推根据eden区的大小推算出Young GC大概多久触发一次，Young GC的平均耗时可以通过 YGCT/YGC 

公式算出，根据结果我们大概就能知道**系统大概多久会因为Young GC的执行而卡顿多久。** 

**每次Young GC后有多少对象存活和进入老年代** 

这个因为之前已经大概知道Young GC的频率，假设是每5分钟一次，那么可以执行命令 jstat -gc pid 300000 10 ，观察每次结果eden， 

survivor和老年代使用的变化情况，在每次gc后eden区使用一般会大幅减少，survivor和老年代都有可能增长，这些增长的对象就是每次 

Young GC后存活的对象，同时还可以看出每次Young GC后进去老年代大概多少对象，从而可以推算出**老年代对象增长速率。** 

**Full GC的触发频率和每次耗时** 

知道了老年代对象的增长速率就可以推算出Full GC的触发频率了，Full GC的每次耗时可以用公式 FGCT/FGC 计算得出。 

**优化思路**其实简单来说就是尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年 

代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响。 

**系统频繁Full GC导致系统卡顿是怎么回事** 

机器配置：2核4G 

JVM内存大小：2G 

系统运行时间：7天 

期间发生的Full GC次数和耗时：500多次，200多秒 

期间发生的Young GC次数和耗时：1万多次，500多秒 

大致算下来每天会发生70多次Full GC，平均每小时3次，每次Full GC在400毫秒左右； 

每天会发生1000多次Young GC，每分钟会发生1次，每次Young GC在50毫秒左右。 

JVM参数设置如下： 

1 ‐Xms1536M ‐Xmx1536M ‐Xmn512M ‐Xss256K ‐XX:SurvivorRatio=6 ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M 

2 ‐XX:+UseParNewGC ‐XX:+UseConcMarkSweepGC ‐XX:CMSInitiatingOccupancyFraction=75 ‐XX:+UseCMSInitiatingOccupancyOnly

##### Jinfo

查看jvm的运行时参数  jinfo -flags 30880\(端口号\)

查看正在运行的Java应用程序的扩展参数  jinfo -sysprop 30880\(端口号\)

##### Jvisualvm 查看GC快照可视化工具

jvisualvm

-XX:HeapDumpPath=D:\jvm.dump

##### Jstack

jstack 20080(进程号) 查找死锁

**jstack**找出占用**cpu**最高的堆栈信息

1，使用命令top -p <pid> ，显示你的java进程的内存情况，pid是你的java进程号，比如4977 

2，按H，获取每个线程的内存情况 

3，找到内存和cpu占用最高的线程tid，比如4977 

4，转为十六进制得到 0x1371 ,此为线程id的十六进制表示5，执行 jstack 4977|grep -A 10 1371，得到线程堆栈信息中1371这个线程所在行的后面10行 

6，查看对应的堆栈信息找出可能存在问题的代码 

##### Jstat

jstat命令可以查看堆内存各部分的使用量

jstat [-命令选项] [vmid] [间隔时间(毫秒)] [查询次数] 

##### jstat -gc 20080（进程号）**最常用**，可以评估程序内存使用及GC压力整体情况 

S0C：第一个幸存区的大小 

S1C：第二个幸存区的大小 

S0U：第一个幸存区的使用大小 

S1U：第二个幸存区的使用大小 

EC：伊甸园区的大小 

EU：伊甸园区的使用大小 

OC：老年代大小 

OU：老年代使用大小 

MC：方法区大小(元空间) 

MU：方法区使用大小 

CCSC:压缩类空间大小 

CCSU:压缩类空间使用大小 

YGC：年轻代垃圾回收次数 

YGCT：年轻代垃圾回收消耗时间，单位sFGC：老年代垃圾回收次数 

FGCT：老年代垃圾回收消耗时间，单位s 

GCT：垃圾回收消耗总时间，单位s 

##### jstat -gccapacity 5268  堆内存统计

NGCMN：新生代最小容量 

NGCMX：新生代最大容量 

NGC：当前新生代容量 

S0C：第一个幸存区大小 

S1C：第二个幸存区的大小 

EC：伊甸园区的大小 

OGCMN：老年代最小容量 

OGCMX：老年代最大容量 

OGC：当前老年代大小 

OC:当前老年代大小 

MCMN:最小元数据容量 

MCMX：最大元数据容量 

MC：当前元数据空间大小 

CCSMN：最小压缩类空间大小 

CCSMX：最大压缩类空间大小 

CCSC：当前压缩类空间大小 

YGC：年轻代gc次数 

FGC：老年代GC次数

##### jstat -gcnew 5268 新生代垃圾回收统计 

S0C：第一个幸存区的大小 

S1C：第二个幸存区的大小 

S0U：第一个幸存区的使用大小 

S1U：第二个幸存区的使用大小 

TT:对象在新生代存活的次数 

MTT:对象在新生代存活的最大次数 

DSS:期望的幸存区大小 

EC：伊甸园区的大小 

EU：伊甸园区的使用大小 

YGC：年轻代垃圾回收次数 

YGCT：年轻代垃圾回收消耗时间 

##### jstat -gcnewcapacity 5268 新生代内存统计

NGCMN：新生代最小容量 

NGCMX：新生代最大容量 

NGC：当前新生代容量 

S0CMX：最大幸存1区大小 

S0C：当前幸存1区大小 

S1CMX：最大幸存2区大小 

S1C：当前幸存2区大小 

ECMX：最大伊甸园区大小 

EC：当前伊甸园区大小 

YGC：年轻代垃圾回收次数FGC：老年代回收次数 

##### jstat -gcold 5268 老年代垃圾回收统计 

MC：方法区大小 

MU：方法区使用大小 

CCSC:压缩类空间大小 

CCSU:压缩类空间使用大小 

OC：老年代大小 

OU：老年代使用大小 

YGC：年轻代垃圾回收次数 

FGC：老年代垃圾回收次数 

FGCT：老年代垃圾回收消耗时间 

GCT：垃圾回收消耗总时间 

##### jstat -gcoldcapacity 5268 老年代内存统计

OGCMN：老年代最小容量 

OGCMX：老年代最大容量 

OGC：当前老年代大小 

OC：老年代大小 

YGC：年轻代垃圾回收次数 

FGC：老年代垃圾回收次数 

FGCT：老年代垃圾回收消耗时间 

GCT：垃圾回收消耗总时间

##### jstat -gcmetacapacity 5268  元数据空间统计

MCMN:最小元数据容量 

MCMX：最大元数据容量 

MC：当前元数据空间大小 

CCSMN：最小压缩类空间大小 

CCSMX：最大压缩类空间大小 

CCSC：当前压缩类空间大小 

YGC：年轻代垃圾回收次数 

FGC：老年代垃圾回收次数 

FGCT：老年代垃圾回收消耗时间 

GCT：垃圾回收消耗总时间

##### jstat -gcutil 5268 

S0：幸存1区当前使用比例 

S1：幸存2区当前使用比例 

E：伊甸园区使用比例 

O：老年代使用比例 

M：元数据区使用比例 

CCS：压缩使用比例 

YGC：年轻代垃圾回收次数 

FGC：老年代垃圾回收次数 

FGCT：老年代垃圾回收消耗时间 

GCT：垃圾回收消耗总时间

##### -XX:+PrintGCDetails -Xloggc:d:\gc.log 打印gc日志

**JVM运行情况预估** 

用 jstat gc -pid 命令可以计算出如下一些关键数据，有了这些数据就可以采用之前介绍过的优化思路，先给自己的系统设置一些初始性的 

JVM参数，比如堆内存大小，年轻代大小，Eden和Survivor的比例，老年代的大小，大对象的阈值，大龄对象进入老年代的阈值等。 

**年轻代对象增长的速率** 

可以执行命令 jstat -gc pid 1000 10 (每隔1秒执行1次命令，共执行10次)，通过观察EU(eden区的使用)来估算每秒eden大概新增多少对 

象，如果系统负载不高，可以把频率1秒换成1分钟，甚至10分钟来观察整体情况。注意，一般系统可能有高峰期和日常期，所以需要在不 

同的时间分别估算不同情况下对象增长速率。 

**Young GC的触发频率和每次耗时** 

知道年轻代对象增长速率我们就能推根据eden区的大小推算出Young GC大概多久触发一次，Young GC的平均耗时可以通过 YGCT/YGC 

公式算出，根据结果我们大概就能知道**系统大概多久会因为Young GC的执行而卡顿多久。** 

**每次Young GC后有多少对象存活和进入老年代** 

这个因为之前已经大概知道Young GC的频率，假设是每5分钟一次，那么可以执行命令 jstat -gc pid 300000 10 ，观察每次结果eden， 

survivor和老年代使用的变化情况，在每次gc后eden区使用一般会大幅减少，survivor和老年代都有可能增长，这些增长的对象就是每次 

Young GC后存活的对象，同时还可以看出每次Young GC后进去老年代大概多少对象，从而可以推算出**老年代对象增长速率。** 

**Full GC的触发频率和每次耗时** 

知道了老年代对象的增长速率就可以推算出Full GC的触发频率了，Full GC的每次耗时可以用公式 FGCT/FGC 计算得出。 

**优化思路**其实简单来说就是尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年 

代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响。 

**系统频繁Full GC导致系统卡顿是怎么回事** 

机器配置：2核4G 

JVM内存大小：2G 

系统运行时间：7天 

期间发生的Full GC次数和耗时：500多次，200多秒 

期间发生的Young GC次数和耗时：1万多次，500多秒 

大致算下来每天会发生70多次Full GC，平均每小时3次，每次Full GC在400毫秒左右； 

每天会发生1000多次Young GC，每分钟会发生1次，每次Young GC在50毫秒左右。 

JVM参数设置如下： 

1 ‐Xms1536M ‐Xmx1536M ‐Xmn512M ‐Xss256K ‐XX:SurvivorRatio=6 ‐XX:MetaspaceSize=256M ‐XX:MaxMetaspaceSize=256M 

2 ‐XX:+UseParNewGC ‐XX:+UseConcMarkSweepGC ‐XX:CMSInitiatingOccupancyFraction=75 ‐XX:+UseCMSInitiatingOccupancyOnly






