\[TOC\]

#### 垃圾回收算法

标记清除算法

算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完 成后统一回收所有被标记的对象。它是最基础的收集算法，效率也很高，但是会 带来两个明显的问题： 1. 效率问题 2. 空间问题（标记清除后会产生大量不连续的碎片）

![](/assets/gcsf1.png)

复制清除算法

为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两 块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到 另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内 存区间的一半进行回收。

![](/assets/gcsf2.png)

标记-整理算法

根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一 样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一段移 动，然后直接清理掉端边界以外的内存。

分代收集算法

当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是 根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代， 这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。 比如在新生代中，每次收集都会有大量对象\(近99%\)死去，所以可以选择复制算 法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象 存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选 择“标记-清除”或“标记-整理”算法进行垃圾收集。注意，“标记-清 除”或“标记-整理”算法会比复制算法慢10倍以上

#### 垃圾回收器

如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。 虽然我们对各个收集器进行比较，但并非为了挑选出一个最好的收集器。因为直到现在为止还没有 最好的垃圾收集器出现，更加没有万能的垃圾收集器，我们能做的就是根据具体应用场景选择适合 自己的垃圾收集器。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么 我们的Java虚拟机就不会实现那么多不同的垃圾收集器了

##### Serial\(串行\)收集器\(-XX:+UseSerialGC  -XX:+UseSerialOldGC\)

Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一 个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ "Stop  The World" ），直到它收集结束。

特点：它简单而高效（与其他收集器的 单线程相比）。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。 Serial Old收集器是Serial收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用 途：**一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是 作为CMS收集器的后备方案**。

**新生代采用复制算法，老年代采用标记-整理算法。**

![](/assets/gcSerial.png)

##### ParNew\(并行\)收集器\(-XX:+UseParNewGC\)

ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为 （控制参数、收集算法、回收策略等等）和Serial收集器完全一样。默认的收集线程数跟cpu核数 相同，当然也可以用参数\(-XX:ParallelGCThreads\)指定收集线程数，但是一般不推荐修改。

**新生代采用复制算法，老年代采用标记-整理算法。**

![](/assets/gcsjq1.png)

它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器 （真正意义上的并发收集器，后面会介绍到）配合工作。

##### Parallel Scavenge收集器\(-XX:+UseParallelGC\(年轻代\),XX:+UseParallelOldGC\(老年代\)\)



![](/assets/gcsjqParallel.png)

##### CMS收集器\(-XX:+UseConcMarkSweepGC\(old\)\)

##### G1收集器\(-XX:+UseG1GC\)



