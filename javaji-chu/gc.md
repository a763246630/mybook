# GC和JVM

[TOC]

java  gc主要是对堆内存和方法区空间的清理（回收没有引用的对象（无GCROOT根引用））。

### 堆内存对象分布结构

![](D:/book/Import/mybook/javaji-chu/assets/%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.png)

##### 堆内存主要分为Eden（新生代），两个Survivor区（to,from）（年轻代包含新生代）,old区（ 老年代）

##### minor GC（young GC）年轻代GC清理年轻代内存空间（回收无引用的对象）

##### full GC（Major GC）一般会回收老年代，年轻代，方法区的垃圾， Major GC的速度一般会比Minor GC的慢10倍以上。

##### 对象gc轮转过程

新创建的对象会放入Eden（伊甸园区）伊甸园区放满会发生minorGC，发生gc会将Eden区存活对象放入Survivor区from，再次发生GC将Eden区和Survivor区from存活对象放入to区。**Survivor不够用直接放入老年代，** 15次GC没有回收的对象会移到老年代，老年代满了会发生fullGC

jvm内存设置案例

日均百万级订单交易系统如何设置JVM参数

![]()

一天百万级订单这个绝对是现在顶尖电商公司交易量级，对于这种量级的系统我们该如何设置JVM参数了？

我们可以试着估算下，其实日均百万订单主要也就是集中在当日的几个小时生成的，我们假设是三小时，也就是每秒大概生成100单左

右。

这种系统我们一般至少要三四台机器去支撑，假设我们部署了四台机器，也就是每台每秒钟大概处理完成25单左右，往上毛估每秒处理**30** 单吧。

双核4G 3台 集群（系统占1G多，方法区分配完，堆最多分配1G多，新生代3分之1占600M\(Eden区8/10 占）每秒100单（480秒发生一次minorGC）可以接受，但是大促时（假设扩大20倍，每秒产生20M对象，24秒就发生一次minorGC） 过于频繁（而且资源（IO，CPU）被占完订单处理会变慢（垃圾对象很可能几十秒还清理，会进入老年代，老年代放满会出现fullGC导致STW），所以要避免资源被占满，预估订单量会变大时适当扩大机器配置（4核8G））。

#### STW（stop the world）

当虚拟机完成两次标记后，便确认了可以回收的对象。但是，**垃圾回收并不会阻塞我们程序的线程，他是与当前程序并发执行的**。所以问题就出在这里，**当GC线程标记好了一个对象的时候，此时我们程序的线程又将该对象重新加入了“关系网”中，当执行二次标记的时候，该对象也没有重写finalize\(\)方法，因此回收的时候就会回收这个不该回收的对象。**   
  **虚拟机的解决方法就是在一些特定指令位置设置一些“安全点”，当程序运行到这些“安全点”的时候就会暂停所有当前运行的线程（Stop The World 所以叫STW），暂停后再找到“GC Roots”进行关系的组建，进而执行标记和清除。**

这些特定的指令**（安全点）位置主要在**：

- 1、循环的末尾
- 2、方法临返回前 / 调用方法的call指令后
- 3、可能抛异常的位置

找到“GC Roots”也是要花很长的时间，然而这里又有新的解决方法，就是通过**采用一个OopMap的数据结构来记录系统中存活的“GC Roots”**，**在类加载完成的时候，虚拟机就把对象内什么偏移量上是什么类型的数据计算出来保存在OopMap，通过解释OopMap就可以找到堆中的对象，这些对象就是GC Roots。而不需要一个一个的去判断某个内存位置的值是不是引用。这种方式也叫准确式GC**。   
  回到最开始的问题，那个**停顿类型就是STW**，至于**有GC和Full GC之分，还有Full GC \(System\)**。个人认为主要是Full GC时STW的时间相对GC来说时间很长，因为Full GC针对整个堆以及永久代的，因此整个GC的范围大大增加；还有就是他的回收算法就是我们之前说过的“标记–清除–整理”，这里也会损耗一定的时间。**所以我们在优化JVM的时候，减少Full GC的次数也是经常用到的办法。**

#### 对象进入老年代的情况

##### 1.大对象直接进入老年代，设置参数（多大的对象直接进老年代）：-XX:PretenureSizeThreshold=1000000单位kb（1M）

大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。JVM参数 -

XX:PretenureSizeThreshold 可以设置大对象的大小，如果对象超过设置大小

会直接进入老年代，不会进入年轻代，这个参数只在 Serial 和ParNew两个收集

器下有效。

比如设置JVM参数：-XX:PretenureSizeThreshold=1000000（10M） -

XX:+UseSerialGC ，再执行下上面的第一个程序会发现大对象直接进了老年代